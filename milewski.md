# Category Theory for Programmers

__Source:__ [Bartosz Milewski's Programming Cafe](http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)

## 1. Category: The Essence of Composition

__Category__: Objects and arrows that go between them
  * Arrows compose
    ```tex
    A -> B, B -> C => A -> C
    ```

__Morph    -- Haskell --ism__: The arrows
  * Functions as morphisms
    ```tex
    f(a) -> b, g(b) -> c => g(f(a)) -> c (~> g∘f)
    ```
    ```haskell
      f :: A -> B -- f has type function from type A to type B
      g :: B -> C
      g . f -- composed
    ```
__Composition__
  * Properties:
    * Associative:
      ```tex
      h∘(g∘f) = (h∘g)∘f = h∘g∘f
      ```
    * Identity function (arrow loops from the object to itself):
      ```tex
      Given f :: A -> B then:

      f∘idA = f; idB∘f = f
      ```
      ```haskell
      id :: a -> a -- Polymorphic declaration; a is any type
      id x = x
      ```

## 2. Types and Functions

__Types__: Sets of values
  * Can be finite or infinite
  * To compose there must be a -> from out1 to out2; Types ensure this match
  * Examples in Haskell:
    * __Void__: Not inhabited by any values
      * Functions taking it can be defined but not called since value would be needed
        ```haskell
        -- Curry-Howard isomorphism: from falsity follows anything
        absurd :: Void -> a
        ```
    * __Singleton__: Contains only one value (called unit)
      * That means we can ellide the value from the function call
        ```haskell
        f44 :: () -> Integer
        f44 () = 44 -- The unit value is ()
        --
        ```
      * Funcs from unit to any type are biunivocal with the elements of that set.
      * __Parametrically polymorphic function__
        * Can be implemented with the same formula for any type
          ```haskell

          -- A whole family of those functions can be implemented as:
          unit :: a -> ()
          unit _ = ()
          ```
    * __Bool__: Contains only two values, True and False
      * Functions to __Bool__ are called __predicates__

__Set__ (category): The category where objects are sets and morphism functions
  * Functions map elements from one set to elements of another
  * Functions can map two elements to one but not one to two
  * Identity functions map each elm of a set to itself

__Hask__: Set category for which each set has been extended with __bottom__
  * The category of Haskell types and functions

__Bottom__: Value that corresponds to non-terminating computation
  * In Haskell
    * Notted as **\_|\_**
    * Every runtime error is treated as bottom
    * Is a member of all types
    * undefined evaluates to bottom
    * Functions that may return it are called partial
    * Functions that can not return it are called total (valid for every arg)

__Functions__
  * If no side effects are called pure
    * In Haskell all functions are pure

## 3. Categories Great and Small

Example categories

__No objects__: Zero objects => Zero morphisms

__Free category__
  * Category generated by connecting each node with each other possible node
  * __Free construction__
    * Completing a given structure by extending it with the min number of items
      to satisfy its laws (in the previous case category laws)

__Hom-set__ (C(a,b))
  * Set of morphisms from object a to object b in a category C

__Orders__
  * A morphism is the relation of being less than or equal => __Preorder__
      => Every hom-set is empty or singleton
        => C(a,a) contains only the identity
  * If also [a <= b and b <= a => a = b] => __Partial order__
      => Can not have cycles
      => Any directed acyclic graph generates it as its free category
  * If also all objects are in a relation with each other => __Total order__
    or __Linear order__
    * Required for most of the sorting algorithms

__Mono    -- Haskell --ids__
  * A set with a binary operation that is:
    * Associative
    * Has a neutral element with respect to the operation
    ```haskell
    class Monoid m whereclass Monoid m where
    mempty  :: m
    mappend :: m -> m -> m
    -- It's programmer's responsability to make sure monoidal properties are satisfied
    ```
  * Can be described as a single category object with a set of morphisms:
    * __Categorical monoid__: One-object category (M)
      => M(m, m) + binary operator __monoidal product__:
        * g·f should exist because source and target are the same
        * Is associative by rules of category
        * Identity morphism is the neutral element
        => A set monoid can always be recovered from a category monoid
          => They are the same

## 4. Kleisli Categories

__Kleisli Category__: A category based on a Monad
  * Its objects are the types of the underlying prgramming language
  * Its morphisms from type A to type B are functions from A to a type derived
    from B using the particular 'embellishment' (endofunctor)
  * It defines:
    * Function composition
    * The identity morphism with respect to the composition operation
  ```haskell
  -- type alias parameterized by a type variable a and equivalent to the pair (a, String)
  type Writer a = (a, String)
  -- Our morphisms are functions from a -> Writer b
  -- Composition is declared with the fish operator
  (>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c)
  -- \x is a lambda of one argument
  -- `let` declare auxiliar variables to be used in the return value defined by the `in` clause
  -- Equality in let pattern matches
  m1 >=> m2 = \x ->
    let (y, s1) = m1 x
        (z, s2) = m2 y
    in (z, s1 ++ s2)
  -- The identity morphism
  return :: a -> Writer a
  return x = (x, "")

  -- Example of the composition in action:

  upCase :: String -> Writer String
  -- `map` applies the toUpper function to the string s
  upCase s = (map toUpper s, "upCase ")

  toWords :: String -> Writer [String]
  toWords s = (words s, "toWords ")

  -- The composition is achieved using the fish operator
  process :: String -> Writer [String]
  process = upCase >=> toWords
  ```

## 5. Products and Coproducts

__Isomorphism__: A pair of morphisms one inverse to the other (invertible morphism)
  * __Isomorphic objects__: Mapping from object a to object b and
  from b to a, each one inverse to the other
  * __Inverse morphisms__
  ```lex
  g is inverse to f <=>
  f . g = id
  g . f = id
  ```

__Initial object__: The object that has one and only one morphism going to any
object in the category (most arrows from it)
  * It may not exist
  * Its uniqueness is not guarenteed
  * Its uniqueness up to unique isomorphism is guaranteed
  * Examples:
    * Least element in _posets_ (partially ordered sets)
    * The Void type in the Set category

__Terminal object__: The object with one and only one morphism coming to it
from any object in the category (least arrows to it)
  * It may not exist
  * Its uniqueness is not guarenteed
  * Its uniqueness up to unique isomorphism is guaranteed
  * Examples:
    * Biggest element in _posets_ (partially ordered sets)
    * The Unit type in the Set category

__Opposite category__ (Cop of C): C with the arrows reversed
  * If composition redefined accordingly:
    ```lex
    For C with:
    h = g∘f
    => Cop with:
    hop = fop∘gop
    ```
    => Is category

__Products__





